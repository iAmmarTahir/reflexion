{"task_id": "median-of-two-sorted-arrays", "prompt": "# Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.\n# \n# \n# Example 1:\n# Input: nums1 = [1,3], nums2 = [2]\n# Output: 2.00000\n# Explanation: merged array = [1,2,3] and median is 2.\n# \n# \n# Example 2:\n# Input: nums1 = [1,2], nums2 = [3,4]\n# Output: 2.50000\n# Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n# \n# \n# Example 3:\n# Input: nums1 = [0,0], nums2 = [0,0]\n# Output: 0.00000\n# \n# Example 4:\n# Input: nums1 = [], nums2 = [1]\n# Output: 1.00000\n# \n# Example 5:\n# Input: nums1 = [2], nums2 = []\n# Output: 2.00000\n# \n# Constraints:\n# `nums1.length == m`\n# `nums2.length == n`\n# `0 <= m <= 1000`\n# `0 <= n <= 1000`\n# `1 <= m + n <= 2000`\n# `-106 <= nums1[i], nums2[i] <= 106`\n# Follow up: The overall run time complexity should be `O(log (m+n))`.\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        ", "entry_point": "findMedianSortedArrays", "cannonical_solution": "", "test": "", "is_solved": false, "reflections": [], "implementations": ["class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        merged = sorted(nums1 + nums2)\n        length = len(merged)\n        if length % 2 == 0:\n            return (merged[length // 2] + merged[length // 2 - 1]) / 2\n        else:\n            return merged[length // 2]"], "test_feedback": ["Tested passed:\nassert Solution().findMedianSortedArrays([1, 2], [3, 4]) == 2.5\n\nTests failed:"], "solution": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        merged = sorted(nums1 + nums2)\n        length = len(merged)\n        if length % 2 == 0:\n            return (merged[length // 2] + merged[length // 2 - 1]) / 2\n        else:\n            return merged[length // 2]"}
{"task_id": "regular-expression-matching", "prompt": "# Given an input string (`s`) and a pattern (`p`), implement regular expression matching with support for `'.'` and `'*'` where:` `\n# `'.'` Matches any single character.​​​​\n# `'*'` Matches zero or more of the preceding element.\n# \n# The matching should cover the entire input string (not partial).\n# \n# \n# Example 1:\n# Input: s = \"aa\", p = \"a\"\n# Output: false\n# Explanation: \"a\" does not match the entire string \"aa\".\n# \n# \n# Example 2:\n# Input: s = \"aa\", p = \"a*\"\n# Output: true\n# Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n# \n# \n# Example 3:\n# Input: s = \"ab\", p = \".*\"\n# Output: true\n# Explanation: \".*\" means \"zero or more (*) of any character (.)\".\n# \n# \n# Example 4:\n# Input: s = \"aab\", p = \"c*a*b\"\n# Output: true\n# Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\".\n# \n# \n# Example 5:\n# Input: s = \"mississippi\", p = \"mis*is*p*.\"\n# Output: false\n# \n# Constraints:\n# `0 <= s.length <= 20`\n# `0 <= p.length <= 30`\n# `s` contains only lowercase English letters.\n# \n# `p` contains only lowercase English letters, `'.'`, and `'*'`.\n# \n# It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.\nclass Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        ", "entry_point": "isMatch", "cannonical_solution": "", "test": "", "is_solved": false, "reflections": ["The implementation failed the test case due to a NameError. The issue is that the test case is trying to call the method isMatch on an object sol which is not defined. The error is not in the function implementation but in the test case itself. To overcome this error, we need to create an instance of the Solution class and then call the isMatch method on that instance. This can be done by replacing sol.isMatch(\"aaa\", \"a*a\") with Solution().isMatch(\"aaa\", \"a*a\") in the test case."], "implementations": ["class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[-1][-1] = True\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                first_match = i < len(s) and p[j] in {s[i], '.'}\n                if j+1 < len(p) and p[j+1] == '*':\n                    dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]\n                else:\n                    dp[i][j] = first_match and dp[i+1][j+1]\n        return dp[0][0]", "        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[-1][-1] = True\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                first_match = i < len(s) and p[j] in {s[i], '.'}\n                if j+1 < len(p) and p[j+1] == '*':\n                    dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]\n                else:\n                    dp[i][j] = first_match and dp[i+1][j+1]\n        return dp[0][0]"], "test_feedback": ["Tested passed:\n\nTests failed:\nassert sol.isMatch(\"aaa\", \"a*a\") == True # output: name 'sol' is not defined", "Tested passed:\n\nTests failed:\nassert sol.isMatch(\"aaa\", \"a*a\") == True # output: unexpected indent (<string>, line 2)"], "solution": "        dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)]\n        dp[-1][-1] = True\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                first_match = i < len(s) and p[j] in {s[i], '.'}\n                if j+1 < len(p) and p[j+1] == '*':\n                    dp[i][j] = dp[i][j+2] or first_match and dp[i+1][j]\n                else:\n                    dp[i][j] = first_match and dp[i+1][j+1]\n        return dp[0][0]"}
{"task_id": "substring-with-concatenation-of-all-words", "prompt": "# You are given a string `s` and an array of strings `words` of the same length. Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters.\n# \n# You can return the answer in any order.\n# \n# \n# Example 1:\n# Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\n# Output: [0,9]\n# Explanation: Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\n# \n# The output order does not matter, returning [9,0] is fine too.\n# \n# \n# Example 2:\n# Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\n# Output: []\n# \n# Example 3:\n# Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\n# Output: [6,9,12]\n# \n# Constraints:\n# `1 <= s.length <= 104`\n# `s` consists of lower-case English letters.\n# \n# `1 <= words.length <= 5000`\n# `1 <= words[i].length <= 30`\n# `words[i]` consists of lower-case English letters.\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        ", "entry_point": "findSubstring", "cannonical_solution": "", "test": "", "is_solved": false, "reflections": [], "implementations": ["class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:\n            return []\n        word_len = len(words[0])\n        word_total = len(words) * word_len\n        s_len = len(s)\n        if s_len < word_total:\n            return []\n        word_counter = Counter(words)\n        res = []\n        for i in range(word_len):\n            left = i\n            right = i\n            cur_counter = Counter()\n            while right + word_len <= s_len:\n                w = s[right:right + word_len]\n                right += word_len\n                cur_counter[w] += 1\n                while cur_counter[w] > word_counter[w]:\n                    left_w = s[left:left + word_len]\n                    left += word_len\n                    cur_counter[left_w] -= 1\n                if right - left == word_total:\n                    res.append(left)\n        return res"], "test_feedback": ["Tested passed:\nassert Solution().findSubstring(\"\", [\"foo\",\"bar\"]) == []\n\nTests failed:"], "solution": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:\n            return []\n        word_len = len(words[0])\n        word_total = len(words) * word_len\n        s_len = len(s)\n        if s_len < word_total:\n            return []\n        word_counter = Counter(words)\n        res = []\n        for i in range(word_len):\n            left = i\n            right = i\n            cur_counter = Counter()\n            while right + word_len <= s_len:\n                w = s[right:right + word_len]\n                right += word_len\n                cur_counter[w] += 1\n                while cur_counter[w] > word_counter[w]:\n                    left_w = s[left:left + word_len]\n                    left += word_len\n                    cur_counter[left_w] -= 1\n                if right - left == word_total:\n                    res.append(left)\n        return res"}
